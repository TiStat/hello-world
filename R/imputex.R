#' @title Imputing censored covariates - GAMLSS
#' @description MICE Algorithm (Multiple Imputation by Chained Equations)
#'   adapted to impute missing & censored data. To do so, inverse sampling is
#'   employed to ensure draws from the valid regions.
#' @param data data.frame containing a dummy censoring indicator, 0 if not
#'   indicator, 1 if indicator
#' @param indicator character. Name of dummy column in data, which indicates the
#'   damaged observation.
#' @param censtype character. type of the damaged observation 'missing',
#'   'right', 'left', 'interval'
#' @param xmu_formula formula for mu
#' @param xsigma_formula formula for sigma
#' @param xnu_formula formula for nu
#' @param xtau_formula formula for tau
#' @param xfamily gamlss family object.
#' @param ... additional arguments passed in all gamlss fit.
#'
#' @return 
#' @export
imputex <- function(xmu_formula,
                    xsigma_formula = ~1,
                    xnu_formula = ~1,
                    xtau_formula = ~1,
                    xfamily = NO(mu.link = 'identity'),
                    data,
                    indicator,
                    censtype,
                    ...)
{
  if(!(is.data.frame(data) && !nrow(data) == 0)){
    stop('data must be (non empty) data.frame')
  }

  if(!(is.character(indicator) && indicator %in% names(data))){
    stop('indicator must be a column name in data')
  }

  #'@description split dataset
  #'@param data dataframe.
  #'@param indicator character. indicating the name of the missing/ (right/left)
  #' censored observation dummy variable in data
  W <- function(data, indicator){ # function name als handlungsanweisung formulieren
    df_obs <- data[data[indicator] == 0, ]
    df_cens <- data[data[indicator] == 1, ]
    return(list(obs = df_obs, cens = df_cens))
  }

  # split dataset in fully observed & missing/censored data
  Wdat <- W(data, indicator)
  censor <- as.character(xmu_formula[[2]])

  # Algorithm --------------------------------------------------------------------

  # Step 1: fit gamlss with user specified xfamily and formula on observed data
  obsmodel <- gamlss(
    formula = xmu_formula,
    sigma_formula = xsigma_formula,
    nu_formula = xnu_formula,
    tau_formula = xtau_formula,
    family = xfamily,
    data = Wdat$obs,
    ...)

  # Step 2: Resampling from fitted model
  # note that these are independent draws from the same distribution. Reframe to m vectors:
  draws <- family_fun(object = obsmodel,
                      func = "r",
                      fitdata = Wdat$obs,
                      predictdata = Wdat$obs,
                      n = nrow(Wdat$obs)*nrow(Wdat$cens))



  draws <- data.frame(matrix(draws,
                             nrow = nrow(Wdat$obs),
                             ncol = nrow(Wdat$cens)))
  # Basis for respective Bootstap samples (draws[,j], W).
  drawsW <- cbind(draws, Wdat$obs)

  # Bootstap samples on simulated vectors (rowwise)
  boot <- drawsW[sample(x= 1:nrow(drawsW),
                        size = nrow(Wdat$obs),
                        replace = TRUE), ]

  # step 3 estimate param. on each respective set {x*boot(j), W_obs} for all j
  bootmodel <- list()
  imputemat <- data.frame(X1 = vector(length= nrow(Wdat$cens)))
  imputeq = list()
  quantil = c(0.05, 0.25, 0.5, 0.75, 0.95)
  for (i in 1:ncol(draws)){
    # iterate only over the names of booted vectors.

    # manipulate the formula for each estimation to get the respective
    # booted x column regressed on W
    bootformula <- as.formula(paste(names(boot)[i], '~',
                                    as.character(as.vector(xmu_formula)[3]),
                                    sep = ''))

    bootmodel[[i]] <- gamlss(formula = bootformula,
                             sigma_formula = xsigma_formula,
                             nu_formula = xnu_formula,
                             xtau_formula = xtau_formula,
                             family = xfamily,
                             data = boot,
                             ...)

    # Simulate data from the corresponding fitted distribution.
    imputecandidate <- names(boot)[i]
    impute = samplecensored(object = bootmodel[[i]],
                            censtype,
                            fitdata = boot,
                            predictdata = Wdat$cens,
                            censor,
                            quantil)
    imputemat[[imputecandidate]] = impute$draw
    imputeq[[i]] = impute$quantiles
  }
  # imputed vector
  imputemat$imputedx <- apply(imputemat, MARGIN = 1, mean)

  # complete data with imputations
  Wdat$cens[censor] <- imputemat$imputedx
  fulldata <- rbind(Wdat$obs,Wdat$cens)

  # variability of imputed vectors
  imputevariance = apply(imputemat[,-ncol(imputemat)], MARGIN = 1, FUN = var)

  # average imputed quantiles
  A = array(unlist(imputeq), dim = c(nrow(imputeq[[1]]), ncol(imputeq[[1]]), length(imputeq)))
  impquantiles = as.data.frame(apply(A, c(1,2), mean))
  colnames(impquantiles) = c('q5','q25','q50', 'q75', 'q95' )

  mcall <- match.call()

  result <- list(imputations = imputemat,
                 fulldata = fulldata,
                 mcall = mcall,
                 number_of_imputations = nrow(Wdat$cens),
                 censoring_type = censtype,
                 number_of_observations = nrow(Wdat$obs) + nrow(Wdat$cens),
                 imputevariance = imputevariance,
                 impquantiles = impquantiles)

  #  Create a class for this kind of result
   class(result) <- "imputed"

  return(result)
}

